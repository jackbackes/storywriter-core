<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: unigram.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: unigram.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var _ = require('lodash');
var Sequelize = require('sequelize');
const bluebird = require('bluebird');

/**
 * [defaultRules are the default Normalization Rules used by Word.parseText()]
 * @type {Array.&lt;Array.&lt;RegExp, String>>}
 */
let defaultRules = [
  // [regex, replace value]
  [/\n/g, '&lt;n>'],
  [/[\.\!\,\?]/g, '$&amp;&lt;/s>&lt;s>']
]
// let phraseParser = /[\w\-]+|[\.\!\,\?]|&lt;n>|&lt;s>|&lt;\/s>/g
let defaultPhraseParser = /[\w\-]+/g

function phraseParser(){
  return defaultPhraseParser;
}

/** @class Word */
module.exports = function (db) {
  db.define('word', {
    word: {
      type: Sequelize.STRING,
      unique: true
    },
    frequency: {
      type: Sequelize.INTEGER,
      defaultValue: 1
    },
    unigramP: {
      type: Sequelize.VIRTUAL,
      get: function() {
        return this.unigramProbability();
      }
    }
  }, {
    /** @lends Word */
    classMethods: {
      /**
       * [incrementWord description]
       * @summary adds or increments a word
       * @param  {String} word [the word to add]
       * @return {Object}      [instance of Word]
       */
      incrementWord(word){
        const Word = db.models['word'];
        return Word.findCreateFind({where: {word}})
                   .spread( (word, created) => {
                     if(!word) throw 'no word'
                     return [word, created];
                   })
                   .spread( (word, created) => {
                     if(created) return word;
                     return word.increment('frequency')
                   })
                   .catch(err => err);
      },
      /**
       * [parseText parses raw text into an array]
       * @param  {String} rawText [a string or String.raw template literal, possibly with multiple lines]
       * @param  {Array.&lt;Array.&lt;RegExp, String>>} [normalizationRules = defaultRules]
       * @return {Array.&lt;String>}         [raw]
       */
      parseText: function(rawText, normalizationRules = defaultRules, parseMatcher = phraseParser()){
        let phraseToMatch = rawText.toLowerCase();
        // let normalizedPhrase = normalizationRules.reduce( (phrase, rule) => phrase.replace(rule[0], rule[1]), phraseToMatch)
        // let normalizedPhraseWithStartAndEnd = `&lt;s>${normalizedPhrase}&lt;/s>`
        let matchedPhraseArray = phraseToMatch.match(parseMatcher);
        let countedMatches = _.countBy(matchedPhraseArray);
        let matchCollection = _.map(countedMatches, (value, key, collection) => {
          return {word: key, frequency: value}
        })
        return matchCollection;
      },
      /**
       * [addPhrase]
       * @param  {String} rawText [a string or String.raw template literal, possibly with multiple lines]
       * @param  {Array.&lt;Array.&lt;RegExp, String>>} [normalizationRules = defaultRules]
       * @see addWordWithFrequency
       * @returns {Promise.&lt;Array.Object>} addedWords
      */
      addPhrase: function(rawText, normalizationRules = defaultRules){
        const Word = db.models['word'];
        let phraseArray = Word.parseText(rawText, normalizationRules);
        return bluebird.mapSeries(phraseArray, (value, index, array) =>{
          return Word.addWordWithFrequency(value)
        } );
      },
      /**
       * @param {Object} wordObject [an map of values for the word]
       * @see addPhrase
       * @see Model.findOrInitialize
       * @returns {Promise}
      */
      addWordWithFrequency: function(wordObject){
        let wordString = wordObject.word, frequency = wordObject.frequency;
        const Word = db.models['word'];
        if(!wordString) throw 'no word';
        if(!frequency) throw 'no frequency';
        return Word.findOrInitialize({where: {word: wordString}})
            .spread(
              (word, initialized) =>
                word.set(
                  'frequency',
                  initialized ? frequency : word.frequency + frequency)
                )
            .then (word => word.save())
      },
    },
    /** @lends Word.prototype */
    instanceMethods: {
      /**
       * [calculates the unigram probability across the entire table]
       * @this {Object} [the word instance]
       * @return {Number} [the probability]
       */
      unigramProbability(){
        let word = this;
        const Word = db.models['word'];
        return Word.sum('frequency')
                   .then( result => Math.floor(word.frequency / result * 10000) )
        }
      }
    }
  )}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Word.html">Word</a></li></ul><h3>Global</h3><ul><li><a href="global.html#defaultRules">defaultRules</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Jun 17 2016 20:26:35 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
